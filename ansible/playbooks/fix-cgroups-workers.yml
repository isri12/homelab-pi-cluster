---
# This playbook fixes the cgroup configuration on worker nodes
# Cgroups are required for Kubernetes to manage resources (CPU/Memory)
# ansible-playbook -i ansible/inventory/hosts.yml ansible/playbooks/fix-cgroups-workers.yml --ask-vault-pass

- name: Fix cmdline.txt on workers
  hosts: workers        # Target the worker nodes group
  become: yes           # Run as root (sudo) because we are editing system files
  
  tasks:
    # Debug: Check what the kernel actually booted with
    - name: Check running kernel arguments
      command: cat /proc/cmdline
      register: running_kernel_args
      changed_when: false

    - name: Display running kernel args
      debug:
        msg: "Kernel booted with: {{ running_kernel_args.stdout }}"

    # Step 1: Read the current boot configuration to see what's there
    - name: Show current cmdline
      command: cat /boot/firmware/cmdline.txt
      register: current_cmd   # Save output to variable 'current_cmd'
      changed_when: false     # This is just a read operation, so don't report 'changed'
      
    - name: Check if cgroups are already active
      shell: cat /proc/cgroups | grep memory
      register: cgroups_active
      ignore_errors: yes
      changed_when: false
      
    # Step 2: Print the current configuration to the Ansible console for debugging
    - name: Display current cmdline
      debug:
        msg: "Current cmdline.txt: {{ current_cmd.stdout }}"
        
    # Step 3: Safety check - verify if 'root=' parameter exists
    # If missing, the file is corrupted and the Pi won't boot properly
    - name: Check if cmdline is valid
      set_fact:
        is_corrupted: "{{ 'root=' not in current_cmd.stdout }}"
        
    # Step 4: If corrupted, overwrite with a standard Ubuntu Pi configuration
    # This restores standard boot params AND adds cgroups
    - name: Repair corrupted cmdline
      shell: |
        echo "console=serial0,115200 multipath=off dwc_otg.lpm_enable=0 console=tty1 root=LABEL=writable rootfstype=ext4 rootwait fixrtc cgroup_enable=cpuset cgroup_memory=1 cgroup_enable=memory" > /boot/firmware/cmdline.txt
        echo "repaired"
      register: repair_result
      when: is_corrupted
      changed_when: "'repaired' in repair_result.stdout"
      
    # Step 5: Read the master node's config just for comparison/reference
    # delegate_to: pi-master makes this task run on the master, even though play is for workers
    - name: Get master's cmdline for reference
      command: cat /boot/firmware/cmdline.txt
      register: master_cmdline
      delegate_to: pi-master
      changed_when: false
      run_once: yes    # Only run this once, not for every worker
      
    - name: Display master's cmdline
      debug:
        msg: "Master cmdline: {{ master_cmdline.stdout }}"
      run_once: yes
      
    # Step 6: The main fix - Add the required cgroup parameters
    # We use a shell script to ensure we don't add duplicates
    - name: Add cgroup parameters properly
      shell: |
        # 1. Identify the active cmdline file by checking config.txt
        CMDLINE_FILE="/boot/firmware/cmdline.txt"
        if [ -f /boot/firmware/config.txt ]; then
            OVERRIDE=$(grep "cmdline=" /boot/firmware/config.txt | tail -1 | cut -d= -f2 | xargs)
            if [ ! -z "$OVERRIDE" ]; then
                CMDLINE_FILE="/boot/firmware/$OVERRIDE"
            fi
        fi

        # Read current line
        CURRENT=$(cat "$CMDLINE_FILE" | tr -d '\n')
        
        # Check if already enabled correctly (including swapaccount) AND no disable flag
        if echo "$CURRENT" | grep -q "cgroup_enable=cpuset cgroup_enable=memory cgroup_memory=1 swapaccount=1" && ! echo "$CURRENT" | grep -q "cgroup_disable=memory"; then
            echo "no_change"
            exit 0
        fi
        
        # Remove any existing cgroup params first
        # Also remove cgroup_disable if present (this is the key fix)
        # We use sed to remove params, tr to squeeze spaces, and sed to trim whitespace to ensure clean formatting
        CLEAN=$(echo "$CURRENT" | sed -e 's/cgroup_enable=[^ ]*//g' -e 's/cgroup_memory=[^ ]*//g' -e 's/cgroup_disable=[^ ]*//g' -e 's/swapaccount=[^ ]*//g' | tr -s ' ' | sed 's/^[ \t]*//;s/[ \t]*$//')
        
        # Add cgroup params at the end
        # We overwrite the file with the clean version + new params
        # Use echo to ensure a newline at the end, which fixes the prompt issue and is standard
        echo "$CLEAN cgroup_enable=cpuset cgroup_enable=memory cgroup_memory=1 swapaccount=1" > "$CMDLINE_FILE"
        echo "changed"
      register: cgroup_update
      changed_when: "'changed' in cgroup_update.stdout"
      when: not is_corrupted  # Skip this if we already repaired the file in Step 4
      
    # Step 6b: Check and fix /boot/cmdline.txt if it exists and is different
    # Some OS versions use this path instead of /boot/firmware/cmdline.txt
    - name: Fix /boot/cmdline.txt if it is a separate file
      shell: |
        FILE="/boot/cmdline.txt"
        # If file exists and is NOT a symlink
        if [ -f "$FILE" ] && [ ! -L "$FILE" ]; then
            CURRENT=$(cat "$FILE" | tr -d '\n')
            if ! echo "$CURRENT" | grep -q "cgroup_enable=cpuset cgroup_enable=memory cgroup_memory=1 swapaccount=1" || echo "$CURRENT" | grep -q "cgroup_disable=memory"; then
                CLEAN=$(echo "$CURRENT" | sed -e 's/cgroup_enable=[^ ]*//g' -e 's/cgroup_memory=[^ ]*//g' -e 's/cgroup_disable=[^ ]*//g' -e 's/swapaccount=[^ ]*//g' | tr -s ' ' | sed 's/^[ \t]*//;s/[ \t]*$//')
                echo "$CLEAN cgroup_enable=cpuset cgroup_enable=memory cgroup_memory=1 swapaccount=1" > "$FILE"
                echo "changed"
            fi
        fi
      register: boot_cmdline_update
      changed_when: "'changed' in boot_cmdline_update.stdout"

    # Step 6c: Aggressively remove cgroup_disable from ANY firmware file
    # This handles nobtcmd.txt, syscfg.txt, or any other file injecting the disable flag
    - name: Remove cgroup_disable from all firmware text files
      shell: |
        # Search for the disable flag in any text file in boot partition
        # We use '|| true' to prevent failure if no files match
        grep -l "cgroup_disable=memory" /boot/firmware/*.txt /boot/*.txt 2>/dev/null | while read file; do
          sed -i 's/ *cgroup_disable=memory//g' "$file"
          echo "cleaned $file"
        done || true
      register: clean_disable
      changed_when: "'cleaned' in clean_disable.stdout"

    # Step 7: Verify the file content after our changes
    - name: Show final cmdline
      command: cat /boot/firmware/cmdline.txt
      register: final_cmd
      changed_when: false
      
    - name: Display final cmdline
      debug:
        msg: "Final cmdline.txt: {{ final_cmd.stdout }}"
        
    # Step 8: Reboot is required for kernel parameters (cmdline.txt) to take effect
    - name: Reboot workers
      reboot:
        reboot_timeout: 300
      when: cgroup_update.changed or (repair_result.changed | default(false)) or (boot_cmdline_update.changed | default(false)) or (clean_disable.changed | default(false)) or cgroups_active.rc != 0
        
    # Step 9: Verify that the kernel actually loaded the cgroups
    # We check /proc/cgroups which shows active cgroup subsystems
    - name: Verify memory cgroup
      shell: cat /proc/cgroups | grep memory
      register: cgroup_verify
      changed_when: false
      
    - name: Display result
      debug:
        msg: "Memory cgroup: {{ cgroup_verify.stdout }}"


# Run it
# ansible-playbook -i ansible/inventory/hosts.yml ansible/playbooks/fix-cgroups-workers.yml --ask-vault-pass